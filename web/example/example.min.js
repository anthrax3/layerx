    (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
    'use strict';

    var crossvent = require('crossvent');
    var taskJsonDataMap = new Array();
    var taskStatusJsonDataMap = new Object();
    var nodeJsonDataMap = new Array();
    var i = 0;

    setInterval(function() {
      startRefresh();
    },5000)


    var savedState = `
        <div id='pending-tasks' class='container movable'>
        </div>
        <div id='staging-tasks' class='container non-movable'>
        </div>
        <div class='container'>
        <div id='nodes' class='container'>
        </div>
        </div>
            `

        startRefresh();

    function startRefresh() {
        $("state").innerHTML = savedState

        refreshTaskStatuses();
        refreshPendingTasks();
        refreshStagingTasks();
        refreshNodes();
    }

    function refreshTaskStatuses() {
        var xhttp = new XMLHttpRequest();
        xhttp.onreadystatechange = function() {
            if (xhttp.readyState == 4) {
                var taskStatuses = JSON.parse(xhttp.responseText)
                for (i = 0; i < taskStatuses.length; i++) {
                    var taskStatus = taskStatuses[i]
                    var taskStatusName = "unnamed"
                    switch(taskStatus.state) {
                      case 0:
                          taskStatusName = "TASK_STARTING"
                          break;
                      case 1:
                          taskStatusName = "TASK_RUNNING"
                          break;
                      case 2:
                          taskStatusName = "TASK_FINISHED"
                          break;
                      case 3:
                          taskStatusName = "TASK_FAILED"
                          break;
                      case 4:
                          taskStatusName = "TASK_KILLED"
                          break;
                      case 5:
                          taskStatusName = "TASK_LOST"
                          break;
                      case 6:
                          taskStatusName = "TASK_STAGING"
                          break;
                      case 7:
                          taskStatusName = "TASK_ERROR"
                          break;
                  }
                    taskStatusJsonDataMap[taskStatus.task_id.value] = taskStatusName;
                }
                console.log("Statuses: "+JSON.stringify(taskStatusJsonDataMap))
            }
        };
        xhttp.open("GET", "/GetStatusUpdates?t=" + Math.random(), true);
        xhttp.send();
    }

    function refreshPendingTasks() {
    var xhttp = new XMLHttpRequest();
    xhttp.onreadystatechange = function() {
        if (xhttp.readyState == 4) {
            var innerHtml = `<div class='non-movable'><h1>Pending Tasks</h1></div>`
            var pendingTasksObj = JSON.parse(xhttp.responseText)
            //alert(pendingTasksObj.length+"   " + JSON.stringify(pendingTasksObj[0]))
            var pendingTasks = pendingTasksObj.sort(function(a, b) {
                    return a.task_id.localeCompare(b.task_id);
                }
            )
            for (i = 0; i < pendingTasks.length; i++) {
                var task = pendingTasks[i]
                taskJsonDataMap[task.task_id] = task;
                innerHtml += "<div task_info_id="+task.task_id+" class='clickable movable'>Task "+task.name+"<br><code>CPUS:"+task.Cpus+"</code><br><code>MEM:"+task.Mem+"</code><br><code>DISK:"+task.Disk+"</code><br><code>STATUS: TASK_PENDING</code></div>"
            }
            $("pending-tasks").innerHTML = innerHtml;
            savedState = $("state").innerHTML
        }
    };
    xhttp.open("GET", "/GetPendingTasks?t=" + Math.random(), true);
    xhttp.send();
    }

    function refreshStagingTasks() {
        var xhttp = new XMLHttpRequest();
        xhttp.onreadystatechange = function() {
            if (xhttp.readyState == 4) {
                var innerHtml = `<div class='non-movable'><h1>Staging Tasks</h1></div>`
                var pendingTasksObj = JSON.parse(xhttp.responseText)
                //alert(pendingTasksObj.length+"   " + JSON.stringify(pendingTasksObj[0]))
                var pendingTasks = pendingTasksObj.sort(function(a, b) {
                        return a.task_id.localeCompare(b.task_id);
                    }
                )
                for (i = 0; i < pendingTasks.length; i++) {
                    var task = pendingTasks[i]
                    taskJsonDataMap[task.task_id] = task;
                    innerHtml += "<div task_info_id="+task.task_id+" class='clickable movable'>Task "+task.name+"<br><code>CPUS:"+task.Cpus+"</code><br><code>MEM:"+task.Mem+"</code><br><code>DISK:"+task.Disk+"</code><br><code>STATUS:"+taskStatusJsonDataMap[task.task_id]+"/code></div>"
                }
                $("staging-tasks").innerHTML = innerHtml;
                savedState = $("state").innerHTML
            }
        };
        xhttp.open("GET", "/GetStagingTasks?t=" + Math.random(), true);
        xhttp.send();
    }

    function refreshNodes() {
        var xhttp = new XMLHttpRequest();
        xhttp.onreadystatechange = function() {
            if (xhttp.readyState == 4) {
                var innerHtml = '';
                var nodesObj = JSON.parse(xhttp.responseText)
                var nodes = nodesObj.sort(function (a, b) {
                        return a.id.localeCompare(b.id);
                    }
                )
                for (i = 0; i < nodes.length; i++) {
                    var node = nodes[i]
                    nodeJsonDataMap[node.id] = node;
                    var cpus = 0
                    var mem = 0
                    var disk = 0
                    for (var key in node.resources) {
                        var resource = node.resources[key]
                        cpus += resource.cpus
                        mem += resource.mem
                        disk += resource.disk
                    }
                    cpus = Number((cpus).toFixed(3))
                    mem = Number((mem).toFixed(3))
                    disk = Number((disk).toFixed(3))
                    innerHtml += "<div class='container'>"
                    innerHtml +=`
                    <div id='`+node.id+`' node_info_id='`+node.id+`' class='container movable node'>
                        <div class='non-movable'>
                            <h1>Node `+i+`<br><code>CPUS:`+cpus+`</code><br><code>MEM:`+mem+`</code><br><code>DISK:`+disk+`</code></h1>
                        </div>
                    </div>`

                    Object.keys(node.tasks).forEach(function (key) {
                        var task = node.tasks[key]
                        taskJsonDataMap[task.task_id] = task;
                        innerHtml += "<div task_info_id="+task.task_id+" class='clickable'>Task "+task.name+"<br><code>CPUS:"+task.Cpus+"</code><br><code>MEM:"+task.Mem+"</code><br><code>DISK:"+task.Disk+"</code><br><code>STATUS:"+taskStatusJsonDataMap[task.task_id]+"</code></div>"
                        console.log(JSON.stringify(task))
                    })
                    innerHtml += "</div>"
                }
                $("nodes").innerHTML = innerHtml;
                savedState = $("state").innerHTML
                addBehaviors()
            }
        };
        xhttp.open("GET", "/GetNodes?t=" + Math.random(), true);
        xhttp.send();
    }

    function assignTask(nodeId, taskId) {
        var xhttp = new XMLHttpRequest();
        xhttp.onreadystatechange = function() {
            if (xhttp.readyState == 4) {
                //alert("submitted "+taskId+" to node "+nodeId)
                startRefresh();
            }
        };
        xhttp.open("POST", "/AssignTasks?t=" + Math.random(), true);
        xhttp.send('{"node_id":"'+nodeId+'","task_ids":["'+taskId+'"]}');
    }

    function clickHandler (e) {
      var target = e.target;

        var containers = []
        var coll = getEls('movable')
        for (var i in coll) {
            containers = containers.concat([$(coll[i].id)])
        }

      if (contains(containers, target)) {
        return;
      }
      if (!contains(getEls(`clickable`), target)) {
        return;
      }
      target.innerHTML += ' [click!]';
        var taskJsonDataId = target.getAttribute("task_info_id");
        var task = taskJsonDataMap[taskJsonDataId]

        //var innerHtml = taskJsonIntoVerboseHtml(target.getAttribute("task_info"));
        $('task-info').innerHTML = "<div><div class='movable'><h1>Task Info</h1></div>"
            +"<div>Task "+task.name
            +"<br><code>CPUS:"+task.Cpus
            +"</code><br><code>MEM:"+task.Mem
            +"</code><br><code>DISK:"+task.Disk
            +"</code><br><code>Task Provider:"+task.task_provider.source
            +"</code><br><code>ENV:"+JSON.stringify(task.command.environment.variables)
            +"</code><br><code>Command:"+task.command.value
            +"</code><br><code>STATUS:TASK_STAGING</code></div>"
            + "</div>";

      setTimeout(function () {
        target.innerHTML = target.innerHTML.replace(/ \[click!\]/g, '');
      }, 500);
    }

    function taskJsonIntoVerboseHtml(taskJson) {
        var task = JSON.parse(taskJson)
        var innerHtml = "foo"
        innerHtml += "<div>Task "+task.name+
            "<br><code>CPUS:"+task.Cpus+
            "</code><br><code>MEM:"+task.Mem+
            "</code><br><code>DISK:"+task.Disk+
            "</code><br><code>Task Provider:"+task.task_provider.source+
            "</code><br><code>ENV:"+JSON.stringify(task.command.environment.variables)+
            "</code><br><code>Command:"+task.command.value+
            "</code><br><code>STATUS:TASK_STAGING</code></div>"
        return innerHtml;
    }

    function $ (id) {
      return document.getElementById(id);
    }

    function getEls (classname) {
      return document.getElementsByClassName(classname);
    }

    function contains(a, obj) {
        for (var i = 0; i < a.length; i++) {
            if (a[i] === obj) {
                return true;
            }
        }
        return false;
    }

    function addBehaviors() {
        var containers = []
        var coll = getEls('movable')
        for (var i in coll) {
            containers = containers.concat([$(coll[i].id)])
        }
        var nodes = getEls('node')
        for (var i in nodes) {
            try {
                console.log("adding node "+nodes[i].id)
                containers = containers.concat([$(nodes[i].id)])
            } catch (e) {
                console.log("failed to add node to containers", e)
            }
        }

        var drake = dragula(containers, {
            moves: function (el, source, handle, sibling) {
                if (contains(getEls('non-movable'), el)) {
                    return false
                }
                return true
            },
            accepts: function (el, target, source, sibling) {
                if (target == $('pending-tasks')) {
                    return false
                }
                if (target == source) {
                    console.log("tried to move "+target+" to "+source)
                    return false
                }
                return true
            }
        })
            .on('drag', function (el) {
                el.className = el.className.replace('ex-moved', '');
            })
            .on('drop', function (el, target, source) {
                el.className += ' ex-moved';
                try {
                    var nodeId = target.getAttribute("node_info_id")
                    var taskId = el.getAttribute("task_info_id")
                    assignTask(nodeId, taskId)
                } catch (e) {
                    console.log("could not assign task", e)
                }
            })
            .on('over', function (el, container) {
                container.className += ' ex-over';
            })
            .on('out', function (el, container) {
                container.className = container.className.replace('ex-over', '');
            })
            .on('click', function (el, container) {
                el.className += ' ex-moved';
            });

        for (var i in containers) {
            if (containers[i]) {
                crossvent.add(containers[i], 'click', clickHandler);
            }
        }
    }

    },{"crossvent":3}],2:[function(require,module,exports){
    (function (global){

    var NativeCustomEvent = global.CustomEvent;

    function useNative () {
      try {
        var p = new NativeCustomEvent('cat', { detail: { foo: 'bar' } });
        return  'cat' === p.type && 'bar' === p.detail.foo;
      } catch (e) {
      }
      return false;
    }

    /**
     * Cross-browser `CustomEvent` constructor.
     *
     * https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent.CustomEvent
     *
     * @public
     */

    module.exports = useNative() ? NativeCustomEvent :

    // IE >= 9
    'function' === typeof document.createEvent ? function CustomEvent (type, params) {
      var e = document.createEvent('CustomEvent');
      if (params) {
        e.initCustomEvent(type, params.bubbles, params.cancelable, params.detail);
      } else {
        e.initCustomEvent(type, false, false, void 0);
      }
      return e;
    } :

    // IE <= 8
    function CustomEvent (type, params) {
      var e = document.createEventObject();
      e.type = type;
      if (params) {
        e.bubbles = Boolean(params.bubbles);
        e.cancelable = Boolean(params.cancelable);
        e.detail = params.detail;
      } else {
        e.bubbles = false;
        e.cancelable = false;
        e.detail = void 0;
      }
      return e;
    }

    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

    },{}],3:[function(require,module,exports){
    (function (global){
    'use strict';

    var customEvent = require('custom-event');
    var eventmap = require('./eventmap');
    var doc = global.document;
    var addEvent = addEventEasy;
    var removeEvent = removeEventEasy;
    var hardCache = [];

    if (!global.addEventListener) {
      addEvent = addEventHard;
      removeEvent = removeEventHard;
    }

    module.exports = {
      add: addEvent,
      remove: removeEvent,
      fabricate: fabricateEvent
    };


    function addEventEasy (el, type, fn, capturing) {
      return el.addEventListener(type, fn, capturing);
    }

    function addEventHard (el, type, fn) {
      return el.attachEvent('on' + type, wrap(el, type, fn));
    }

    function removeEventEasy (el, type, fn, capturing) {
      return el.removeEventListener(type, fn, capturing);
    }

    function removeEventHard (el, type, fn) {
      var listener = unwrap(el, type, fn);
      if (listener) {
        return el.detachEvent('on' + type, listener);
      }
    }

    function fabricateEvent (el, type, model) {
      var e = eventmap.indexOf(type) === -1 ? makeCustomEvent() : makeClassicEvent();
      if (el.dispatchEvent) {
        el.dispatchEvent(e);
      } else {
        el.fireEvent('on' + type, e);
      }
      function makeClassicEvent () {
        var e;
        if (doc.createEvent) {
          e = doc.createEvent('Event');
          e.initEvent(type, true, true);
        } else if (doc.createEventObject) {
          e = doc.createEventObject();
        }
        return e;
      }
      function makeCustomEvent () {
        return new customEvent(type, { detail: model });
      }
    }

    function wrapperFactory (el, type, fn) {
      return function wrapper (originalEvent) {
        var e = originalEvent || global.event;
        e.target = e.target || e.srcElement;
        e.preventDefault = e.preventDefault || function preventDefault () { e.returnValue = false; };
        e.stopPropagation = e.stopPropagation || function stopPropagation () { e.cancelBubble = true; };
        e.which = e.which || e.keyCode;
        fn.call(el, e);
      };
    }

    function wrap (el, type, fn) {
      var wrapper = unwrap(el, type, fn) || wrapperFactory(el, type, fn);
      hardCache.push({
        wrapper: wrapper,
        element: el,
        type: type,
        fn: fn
      });
      return wrapper;
    }

    function unwrap (el, type, fn) {
      var i = find(el, type, fn);
      if (i) {
        var wrapper = hardCache[i].wrapper;
        hardCache.splice(i, 1); // free up a tad of memory
        return wrapper;
      }
    }

    function find (el, type, fn) {
      var i, item;
      for (i = 0; i < hardCache.length; i++) {
        item = hardCache[i];
        if (item.element === el && item.type === type && item.fn === fn) {
          return i;
        }
      }
    }

    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

    },{"./eventmap":4,"custom-event":2}],4:[function(require,module,exports){
    (function (global){
    'use strict';

    var eventmap = [];
    var eventname = '';
    var ron = /^on/;

    for (eventname in global) {
      if (ron.test(eventname)) {
        eventmap.push(eventname.slice(2));
      }
    }

    module.exports = eventmap;

    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

    },{}]},{},[1])
